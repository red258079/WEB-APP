<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L√†m B√†i Thi - EDEXIS</title>
    <link rel="icon" type="image/png" href="/client/public/images/edu.png">
    <link rel="stylesheet" href="/client/public/css/variables.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
    <script src="/client/public/js/config.js"></script>
    <script src="/client/public/js/api.js"></script>
    <script src="/client/public/js/aiCheatingDetection.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background: var(--bg-gradient);
            min-height: 100vh;
            padding: var(--spacing-lg);
        }

        .exam-container {
            max-width: var(--container-max-width);
            margin: 0 auto;
            background: var(--white);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            overflow: hidden;
        }

        .exam-header {
            background: var(--primary-gradient);
            color: var(--white);
            padding: var(--spacing-lg) var(--spacing-xl);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: var(--spacing-md);
        }

        .exam-title {
            font-size: 24px;
            font-weight: 600;
        }

        .timer {
            font-size: 28px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 150px;
            text-align: center;
        }

        .timer.warning {
            background: #ff4757;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .exam-body {
            padding: 30px;
        }

        .question-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e1e8ed;
        }

        .question-nav-btn {
            width: 45px;
            height: 45px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .question-nav-btn:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .question-nav-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .question-nav-btn.answered {
            background: #26de81;
            color: white;
            border-color: #26de81;
        }

        .question-content {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .question-text {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2d3748;
        }

        .question-meta {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .meta-badge {
            background: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: 600;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option {
            background: white;
            padding: 15px 20px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .option:hover {
            border-color: #667eea;
            transform: translateX(5px);
        }

        .option input {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .option.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .textarea-answer {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 16px;
            resize: vertical;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: space-between;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--primary-gradient);
            color: var(--white);
        }

        .btn-primary:hover {
            background: var(--primary-gradient-hover);
        }

        .btn-success {
            background: var(--success-color);
            color: var(--white);
        }

        .btn-success:hover {
            background: var(--success-dark);
        }

        .btn-warning {
            background: linear-gradient(45deg, #ffa502, #ff6348);
            color: var(--white);
        }

        .btn-warning:hover {
            background: linear-gradient(45deg, #ff6348, #ff4757);
        }

        .btn-secondary {
            background: var(--gray-500);
            color: var(--white);
        }

        .btn-secondary:hover {
            background: var(--gray-600);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            background: #ddd;
            cursor: not-allowed;
            transform: none;
        }

        .webcam-container {
            position: fixed;
            bottom: var(--spacing-lg);
            right: var(--spacing-lg);
            width: 200px;
            border: 3px solid var(--primary-color);
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            z-index: var(--z-fixed);
        }

        #localVideo {
            width: 100%;
            display: block;
        }

        .webcam-status {
            background: var(--success-color);
            color: var(--white);
            padding: var(--spacing-xs);
            text-align: center;
            font-size: var(--font-size-xs);
            font-weight: 600;
        }

        .warning-banner {
            background: var(--danger-color);
            color: var(--white);
            padding: var(--spacing-md);
            text-align: center;
            font-weight: 600;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: var(--z-tooltip);
            display: none;
        }

        .warning-banner.show {
            display: block;
            animation: slideDown 0.3s;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-100%);
            }

            to {
                transform: translateY(0);
            }
        }

        .toast {
            position: fixed;
            top: 80px;
            right: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            z-index: 9999;
            transform: translateX(400px);
            transition: transform 0.3s;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.error {
            border-left: 5px solid var(--danger-color);
        }

        .toast.success {
            border-left: 5px solid var(--success-color);
        }

        .toast.warning {
            border-left: 5px solid var(--warning-color);
        }

        /* ============================================
           RESPONSIVE STYLES
           ============================================ */

        /* Mobile (0px - 575px) */
        @media (max-width: 575.98px) {
            body {
                padding: var(--spacing-sm);
            }

            .exam-container {
                border-radius: var(--radius-lg);
            }

            .exam-header {
                flex-direction: column;
                text-align: center;
                padding: var(--spacing-md);
                gap: var(--spacing-sm);
            }

            .exam-title {
                font-size: var(--font-size-lg);
                line-height: 1.3;
            }

            .exam-header>div:first-child {
                width: 100%;
            }

            .exam-header>div:first-child>div:last-child {
                font-size: 12px;
                margin-top: 5px;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }

            .timer {
                font-size: 20px;
                min-width: auto;
                width: 100%;
                padding: var(--spacing-sm) var(--spacing-md);
            }

            .exam-body {
                padding: var(--spacing-md);
            }

            .question-nav {
                gap: 6px;
                margin-bottom: var(--spacing-lg);
                justify-content: center;
            }

            .question-nav-btn {
                width: 32px;
                height: 32px;
                font-size: 12px;
                padding: 0;
            }

            .question-content {
                padding: var(--spacing-md);
            }

            .question-text {
                font-size: var(--font-size-base);
            }

            .webcam-container {
                width: 120px;
                bottom: var(--spacing-sm);
                right: var(--spacing-sm);
            }

            .webcam-status {
                font-size: var(--font-size-xs);
                padding: var(--spacing-xs);
            }

            .action-buttons {
                flex-direction: column;
                gap: var(--spacing-sm);
            }

            .action-buttons .btn {
                width: 100%;
                padding: var(--spacing-sm) var(--spacing-md);
                font-size: var(--font-size-sm);
            }

            .modal-content {
                width: 95%;
                padding: var(--spacing-lg);
                max-height: 90vh;
            }

            .option {
                padding: var(--spacing-sm) var(--spacing-md);
                font-size: var(--font-size-sm);
            }

            .textarea-answer {
                min-height: 120px;
                font-size: var(--font-size-sm);
            }
        }

        /* Large Mobile / Small Tablet (576px - 767px) */
        @media (min-width: 576px) and (max-width: 767.98px) {
            .exam-header {
                flex-direction: column;
                text-align: center;
                gap: var(--spacing-sm);
            }

            .webcam-container {
                width: 150px;
            }

            .action-buttons {
                flex-wrap: wrap;
            }

            .action-buttons .btn {
                flex: 1;
                min-width: 120px;
            }
        }

        /* Tablet (768px - 991px) */
        @media (min-width: 768px) and (max-width: 991.98px) {
            .exam-container {
                max-width: 100%;
            }

            .webcam-container {
                width: 180px;
            }
        }

        /* Desktop (992px+) */
        @media (min-width: 992px) {
            .exam-container {
                max-width: 1200px;
            }
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            z-index: 1;
        }

        .unanswered-list {
            max-height: 300px;
            overflow-y: auto;
            text-align: left;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .unanswered-item {
            padding: 8px;
            margin-bottom: 8px;
            background: white;
            border-radius: 5px;
            border-left: 3px solid #ffa502;
            font-size: 14px;
        }

        @media (max-width: 575.98px) {
            .modal-content {
                padding: 20px 15px;
                width: 95%;
                max-height: 85vh;
            }

            .modal-content h2 {
                font-size: 18px;
                margin-bottom: 15px;
            }

            .unanswered-list {
                max-height: 200px;
                font-size: 13px;
            }

            .unanswered-item {
                padding: 6px;
                font-size: 12px;
            }

            .close-btn {
                top: 5px;
                right: 10px;
                font-size: 20px;
            }

            .modal-content .btn {
                width: 100%;
                margin-top: 10px;
                padding: 12px;
            }
        }

        /* Log Panel Styles */
        .log-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 600px;
            max-height: 85vh;
            background: rgba(0, 0, 0, 0.98);
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border: 2px solid #0f0;
            border-radius: 8px;
            z-index: 10000;
            display: none;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 255, 0, 0.5);
        }

        .log-panel.visible {
            display: flex;
        }

        .log-panel-header {
            background: #0f0;
            color: #000;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            cursor: move;
        }

        .log-panel-controls {
            display: flex;
            gap: 8px;
        }

        .log-panel-btn {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 10px;
        }

        .log-panel-btn:hover {
            background: #0f0;
            color: #000;
        }

        .log-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            max-height: calc(80vh - 60px);
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 2px 4px;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .log-entry.error {
            color: #f00;
        }

        .log-entry.warn {
            color: #ff0;
        }

        .log-entry.info {
            color: #0ff;
        }

        .log-entry.debug {
            color: #0f0;
        }

        .log-timestamp {
            color: #888;
            margin-right: 8px;
        }
    </style>
</head>

<body>
    <div class="warning-banner" id="warningBanner"></div>

    <!-- Log Panel -->
    <div class="log-panel" id="logPanel">
        <div class="log-panel-header" id="logPanelHeader">
            <span>üìã Debug Log (Nh·∫•n Ctrl+Shift+L ƒë·ªÉ m·ªü/ƒë√≥ng)</span>
            <div class="log-panel-controls">
                <button class="log-panel-btn" onclick="clearLogs()">Clear</button>
                <button class="log-panel-btn" onclick="copyLogs()">Copy</button>
                <button class="log-panel-btn" onclick="toggleLogPanel()">‚úï</button>
            </div>
        </div>
        <div class="log-panel-content" id="logPanelContent"></div>
    </div>

    <div class="exam-container">
        <div class="exam-header">
            <div>
                <div class="exam-title" id="examTitle">ƒêang t·∫£i...</div>
                <div style="font-size: 14px; opacity: 0.9; margin-top: 5px;">
                    <span id="questionProgress">0/0 c√¢u</span> ‚Ä¢
                    <span id="tabSwitchWarning">Chuy·ªÉn tab: 0/3</span>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <!-- ƒê√£ b·ªè n√∫t üìã Log, ch·ªâ gi·ªØ ƒë·ªìng h·ªì -->
                <div class="timer" id="timer">00:00:00</div>
            </div>
        </div>

        <div class="exam-body">
            <div class="question-nav" id="questionNav"></div>

            <div class="question-content">
                <div id="questionContainer">
                    <p style="text-align: center; color: #666;">‚è≥ ƒêang t·∫£i c√¢u h·ªèi...</p>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-secondary" id="prevBtn" onclick="previousQuestion()">‚Üê C√¢u tr∆∞·ªõc</button>
                <button class="btn btn-primary" id="nextBtn" onclick="nextQuestion()">C√¢u sau ‚Üí</button>
                <button class="btn btn-success" id="submitBtn" onclick="submitExam()">üì§ N·ªôp b√†i</button>
            </div>
        </div>
    </div>

    <div class="webcam-container">
        <video id="localVideo" autoplay muted></video>
        <div class="webcam-status" id="webcamStatus">üî¥ ƒêang k·∫øt n·ªëi...</div>
    </div>

    <!-- Modal c·∫£nh b√°o c√¢u h·ªèi ch∆∞a l√†m -->
    <div id="unansweredWarningModal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-btn" onclick="closeUnansweredModal()">&times;</span>
            <h2>‚ö†Ô∏è C·∫£nh b√°o</h2>
            <div id="unansweredWarningContent" style="margin: 20px 0;">
                <!-- N·ªôi dung s·∫Ω ƒë∆∞·ª£c ƒëi·ªÅn ƒë·ªông -->
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="closeUnansweredModal()">Quay l·∫°i l√†m b√†i</button>
                <button class="btn btn-warning" onclick="confirmSubmitWithUnanswered()">V·∫´n n·ªôp b√†i</button>
            </div>
        </div>
    </div>

    <div id="submitModal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal()">&times;</span>
            <h2>üéâ N·ªôp b√†i th√†nh c√¥ng!</h2>
            <p>ƒêi·ªÉm c·ªßa b·∫°n: <span id="modalScore" style="font-weight: bold; font-size: 24px;">--/--</span></p>
            <p id="modalMessage"></p>
            <button class="btn btn-primary" onclick="goToResult()">Xem chi ti·∫øt k·∫øt qu·∫£</button>
        </div>
    </div>

    <script>
        // ‚≠ê LOG PANEL SYSTEM - L∆∞u t·∫•t c·∫£ log ƒë·ªÉ kh√¥ng b·ªã m·∫•t khi reload
        const logStorage = {
            logs: [],
            maxLogs: 1000,

            init() {
                // Load logs t·ª´ localStorage n·∫øu c√≥
                try {
                    const saved = localStorage.getItem('debug_logs');
                    if (saved) {
                        this.logs = JSON.parse(saved);
                        this.renderLogs();
                    }
                } catch (e) {
                    console.error('L·ªói load logs:', e);
                }

                // Override console methods
                this.overrideConsole();

                // Keyboard shortcut ƒë·ªÉ toggle log panel (CH·ªà d√πng Ctrl+Shift+L, KH√îNG ƒë·ª•ng F12)
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                        e.preventDefault();
                        toggleLogPanel();
                    }
                });
            },

            overrideConsole() {
                const originalLog = console.log;
                const originalError = console.error;
                const originalWarn = console.warn;
                const originalInfo = console.info;

                const addLog = (type, args) => {
                    const timestamp = new Date().toLocaleTimeString('vi-VN');
                    const message = args.map(arg => {
                        if (typeof arg === 'object') {
                            try {
                                return JSON.stringify(arg, null, 2);
                            } catch (e) {
                                return String(arg);
                            }
                        }
                        return String(arg);
                    }).join(' ');

                    const logEntry = {
                        type: type,
                        timestamp: timestamp,
                        message: message,
                        fullMessage: args.map(arg => {
                            if (typeof arg === 'object') {
                                try {
                                    return JSON.stringify(arg, null, 2);
                                } catch (e) {
                                    return String(arg);
                                }
                            }
                            return String(arg);
                        }).join(' ')
                    };

                    this.logs.push(logEntry);
                    if (this.logs.length > this.maxLogs) {
                        this.logs.shift();
                    }

                    // L∆∞u v√†o localStorage
                    try {
                        localStorage.setItem('debug_logs', JSON.stringify(this.logs));
                    } catch (e) {
                        // localStorage ƒë·∫ßy, x√≥a logs c≈©
                        this.logs = this.logs.slice(-500);
                        localStorage.setItem('debug_logs', JSON.stringify(this.logs));
                    }

                    // Render v√†o UI
                    this.renderLogs();

                    // G·ªçi original console method
                    return { type, args };
                };

                console.log = function (...args) {
                    const result = addLog('debug', args);
                    originalLog.apply(console, args);
                };

                console.error = function (...args) {
                    const result = addLog('error', args);
                    originalError.apply(console, args);
                };

                console.warn = function (...args) {
                    const result = addLog('warn', args);
                    originalWarn.apply(console, args);
                };

                console.info = function (...args) {
                    const result = addLog('info', args);
                    originalInfo.apply(console, args);
                };
            },

            renderLogs() {
                const panel = document.getElementById('logPanelContent');
                if (!panel) return;

                panel.innerHTML = '';
                this.logs.forEach(log => {
                    const entry = document.createElement('div');
                    entry.className = `log-entry ${log.type}`;
                    entry.innerHTML = `<span class="log-timestamp">[${log.timestamp}]</span>${log.message}`;
                    panel.appendChild(entry);
                });

                // Auto scroll to bottom
                panel.scrollTop = panel.scrollHeight;
            },

            clear() {
                this.logs = [];
                localStorage.removeItem('debug_logs');
                this.renderLogs();
            },

            copy() {
                const text = this.logs.map(log =>
                    `[${log.timestamp}] [${log.type.toUpperCase()}] ${log.fullMessage}`
                ).join('\n');

                navigator.clipboard.writeText(text).then(() => {
                    alert('‚úÖ ƒê√£ copy log v√†o clipboard!');
                }).catch(err => {
                    console.error('L·ªói copy:', err);
                });
            }
        };

        function toggleLogPanel() {
            const panel = document.getElementById('logPanel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }

        function clearLogs() {
            logStorage.clear();
        }

        function copyLogs() {
            logStorage.copy();
        }

        // Kh·ªüi t·∫°o log system ngay khi script load
        logStorage.init();

        const token = localStorage.getItem('token');
        const userId = localStorage.getItem('user_id');

        let socket;
        let examData = null;
        let currentQuestionIndex = 0;
        let answers = {};
        let tabSwitchCount = 0;
        let timerInterval = null;
        let timeRemaining = 0;
        let aiDetection = null; // AI cheating detection instance

        // QUAN TR·ªåNG: B·∫Øt l·ªói unhandled promise rejection ƒë·ªÉ tr√°nh reload
        window.addEventListener('unhandledrejection', (event) => {
            console.error('üîç [DEBUG] [UnhandledRejection] ‚ö†Ô∏è PH√ÅT HI·ªÜN UNHANDLED REJECTION!');
            console.error('üîç [DEBUG] [UnhandledRejection] Reason:', event.reason);
            console.error('üîç [DEBUG] [UnhandledRejection] Promise:', event.promise);
            console.error('üîç [DEBUG] [UnhandledRejection] Stack trace:', new Error().stack);

            // Log chi ti·∫øt error object
            if (event.reason instanceof Error) {
                console.error('üîç [DEBUG] [UnhandledRejection] Error details:', {
                    message: event.reason.message,
                    name: event.reason.name,
                    stack: event.reason.stack,
                    cause: event.reason.cause
                });
            }

            // Ki·ªÉm tra xem c√≥ ph·∫£i t·ª´ AI Detection kh√¥ng
            const reasonStr = String(event.reason || '');
            const reasonStack = event.reason?.stack || '';
            const isFromAIDetection = reasonStr.includes('AI Detection') ||
                reasonStr.includes('aiCheatingDetection') ||
                reasonStack.includes('aiCheatingDetection') ||
                reasonStack.includes('handleViolation') ||
                reasonStack.includes('_recordViolationVideo') ||
                reasonStack.includes('logCheating') ||
                reasonStack.includes('onViolationDetected');

            if (isFromAIDetection) {
                console.error('üîç [DEBUG] [UnhandledRejection] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è L·ªñI T·ª™ AI DETECTION! ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è');
            }

            // NgƒÉn kh√¥ng cho tr√¨nh duy·ªát reload
            event.preventDefault();
            console.log('üîç [DEBUG] [UnhandledRejection] ƒê√£ preventDefault - kh√¥ng reload');
            // Ch·ªâ log l·ªói, kh√¥ng l√†m g√¨ kh√°c
            return false; // NgƒÉn kh√¥ng cho tr√¨nh duy·ªát x·ª≠ l√Ω l·ªói
        });

        // QUAN TR·ªåNG: B·∫Øt l·ªói JavaScript ƒë·ªÉ tr√°nh reload
        window.addEventListener('error', (event) => {
            console.error('üîç [DEBUG] [GlobalError] ‚ö†Ô∏è PH√ÅT HI·ªÜN JAVASCRIPT ERROR!');
            console.error('üîç [DEBUG] [GlobalError] Message:', event.message);
            console.error('üîç [DEBUG] [GlobalError] Source:', event.filename, 'Line:', event.lineno, 'Col:', event.colno);
            console.error('üîç [DEBUG] [GlobalError] Error:', event.error);
            console.error('üîç [DEBUG] [GlobalError] Stack trace:', event.error?.stack);

            // Ki·ªÉm tra xem c√≥ ph·∫£i t·ª´ AI Detection kh√¥ng
            const isFromAIDetection = event.filename?.includes('aiCheatingDetection') ||
                event.error?.stack?.includes('aiCheatingDetection') ||
                event.error?.stack?.includes('handleViolation') ||
                event.error?.stack?.includes('_recordViolationVideo');

            if (isFromAIDetection) {
                console.error('üîç [DEBUG] [GlobalError] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è L·ªñI T·ª™ AI DETECTION! ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è');
            }

            // NgƒÉn kh√¥ng cho tr√¨nh duy·ªát reload
            event.preventDefault();
            console.log('üîç [DEBUG] [GlobalError] ƒê√£ preventDefault - kh√¥ng reload');
            return false; // NgƒÉn kh√¥ng cho tr√¨nh duy·ªát x·ª≠ l√Ω l·ªói
        });

        // QUAN TR·ªåNG: NgƒÉn kh√¥ng cho tr√¨nh duy·ªát t·ª± ƒë·ªông reload khi c√≥ l·ªói
        const originalReload = window.location.reload;

        // Helper function ƒë·ªÉ track t·∫•t c·∫£ active timeouts
        const activeTimeouts = new Map();
        const originalSetTimeout = window.setTimeout;
        window.setTimeout = function (...args) {
            const timeoutId = originalSetTimeout.apply(this, args);
            const delay = args[1] || 0;
            activeTimeouts.set(timeoutId, {
                delay: delay,
                createdAt: Date.now(),
                stack: new Error().stack
            });
            console.log(`üîç [Timeout] Created timeout ID: ${timeoutId}, delay: ${delay}ms, active count: ${activeTimeouts.size}`);
            // Auto remove sau khi timeout ch·∫°y
            originalSetTimeout(() => {
                activeTimeouts.delete(timeoutId);
            }, delay + 100);
            return timeoutId;
        };

        const originalClearTimeout = window.clearTimeout;
        window.clearTimeout = function (timeoutId) {
            if (activeTimeouts.has(timeoutId)) {
                console.log(`üîç [Timeout] Cleared timeout ID: ${timeoutId}`);
                activeTimeouts.delete(timeoutId);
            }
            return originalClearTimeout.apply(this, arguments);
        };

        function getAllActiveTimeouts() {
            const now = Date.now();
            return Array.from(activeTimeouts.entries()).map(([id, info]) => ({
                id: id,
                delay: info.delay,
                elapsed: now - info.createdAt,
                remaining: Math.max(0, info.delay - (now - info.createdAt)),
                stack: info.stack
            }));
        }

        window.location.reload = function (forcedReload) {
            const reloadId = `reload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            console.error(`üîç [DEBUG] [${reloadId}] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è PH√ÅT HI·ªÜN ATTEMPT TO RELOAD PAGE! ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è`);
            console.error(`üîç [DEBUG] [${reloadId}] Forced reload:`, forcedReload);
            console.error(`üîç [DEBUG] [${reloadId}] Stack trace:`, new Error().stack);
            console.error(`üîç [DEBUG] [${reloadId}] Active timeouts:`, getAllActiveTimeouts());
            console.warn(`‚ö†Ô∏è [Blocked] Attempt to reload page blocked - ID: ${reloadId}`);

            // T·ª± ƒë·ªông m·ªü log panel khi c√≥ attempt reload
            setTimeout(() => {
                const panel = document.getElementById('logPanel');
                if (panel && !panel.classList.contains('visible')) {
                    panel.classList.add('visible');
                }
            }, 100);

            // KH√îNG reload - ch·ªâ log
            return false;
        };

        // ‚≠ê X√ìA HO√ÄN TO√ÄN beforeunload listener - KH√îNG C·∫¶N THI·∫æT
        // Browser s·∫Ω t·ª± ƒë·ªông hi·ªÉn th·ªã popup n·∫øu c√≥ beforeunload listener
        // Thay v√†o ƒë√≥, ch√∫ng ta block reload b·∫±ng c√°ch override window.location.reload (ƒë√£ c√≥ ·ªü tr√™n)
        // KH√îNG th√™m listener n√†y ƒë·ªÉ tr√°nh popup xu·∫•t hi·ªán

        // Ch·ªâ log khi c√≥ attempt reload (t·ª´ window.location.reload override)
        // KH√îNG d√πng beforeunload event

        // ‚≠ê X√ìA unload listener - KH√îNG C·∫¶N THI·∫æT
        // unload event c√≥ th·ªÉ trigger khi page reload, g√¢y ra v√≤ng l·∫∑p
        // Ch·ªâ log khi c√≥ attempt reload t·ª´ window.location.reload override (ƒë√£ c√≥ ·ªü tr√™n)

        document.addEventListener('DOMContentLoaded', async function () {
            if (!token) {
                alert('‚ùå Vui l√≤ng ƒëƒÉng nh·∫≠p!');
                window.location.href = './login.html';
                return;
            }

            // Ki·ªÉm tra URL c√≥ attempt_id kh√¥ng (khi reload trang)
            const urlParams = new URLSearchParams(window.location.search);
            let attemptIdFromUrl = urlParams.get('attempt_id');
            let examIdFromUrl = urlParams.get('exam_id');

            // QUAN TR·ªåNG: Clear answers c≈© n·∫øu attempt_id kh√°c v·ªõi attempt_id trong localStorage
            // ƒê·∫£m b·∫£o m·ªói attempt ch·ªâ load answers c·ªßa ch√≠nh n√≥
            const savedExamInfo = localStorage.getItem('current_exam');
            if (savedExamInfo) {
                try {
                    const savedExam = JSON.parse(savedExamInfo);
                    // N·∫øu attempt_id trong localStorage kh√°c v·ªõi attempt_id trong URL, clear localStorage
                    if (savedExam.attempt_id && attemptIdFromUrl &&
                        String(savedExam.attempt_id) !== String(attemptIdFromUrl)) {
                        console.warn('‚ö†Ô∏è [Security] Attempt ID kh√°c nhau, clear localStorage c≈©');
                        localStorage.removeItem('exam_answers');
                        localStorage.removeItem('current_exam');
                    }
                } catch (e) {
                    console.error('‚ùå L·ªói parse savedExamInfo:', e);
                }
            }

            // Ki·ªÉm tra localStorage tr∆∞·ªõc ƒë·ªÉ l·∫•y attempt_id v√† exam_id
            const examInfo = localStorage.getItem('current_exam');
            let attemptId = attemptIdFromUrl;
            let examId = examIdFromUrl;

            // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p exam_id ho·∫∑c attempt_id l√† "null" (string) ho·∫∑c null
            if (examId === 'null' || examId === null || !examId) {
                examId = null;
            }
            if (attemptId === 'null' || attemptId === null || !attemptId) {
                attemptId = null;
            }

            // N·∫øu URL kh√¥ng c√≥ ho·∫∑c l√† null, l·∫•y t·ª´ localStorage
            if (!attemptId || !examId) {
                if (examInfo) {
                    try {
                        const savedExamData = JSON.parse(examInfo);
                        if (savedExamData.attempt_id && savedExamData.exam_id) {
                            attemptId = savedExamData.attempt_id;
                            examId = savedExamData.exam_id;

                            // C·∫≠p nh·∫≠t URL ngay l·∫≠p t·ª©c ƒë·ªÉ c√≥ attempt_id v√† exam_id h·ª£p l·ªá
                            // CH·ªà c·∫≠p nh·∫≠t n·∫øu URL hi·ªán t·∫°i kh√°c v·ªõi URL m·ªõi (tr√°nh trigger reload kh√¥ng c·∫ßn thi·∫øt)
                            const currentUrl = new URL(window.location.href);
                            const currentExamId = currentUrl.searchParams.get('exam_id');
                            const currentAttemptId = currentUrl.searchParams.get('attempt_id');

                            if (currentExamId !== String(examId) || currentAttemptId !== String(attemptId)) {
                                const newUrl = new URL(window.location.href);
                                newUrl.searchParams.set('exam_id', examId);
                                newUrl.searchParams.set('attempt_id', attemptId);
                                window.history.replaceState({}, '', newUrl);
                            }
                        }
                    } catch (e) {
                        console.error('‚ùå L·ªói parse examInfo t·ª´ localStorage:', e);
                    }
                }
            }

            // Ki·ªÉm tra l·∫°i sau khi l·∫•y t·ª´ localStorage
            if (!attemptId || !examId || examId === 'null' || attemptId === 'null') {
                // N·∫øu v·∫´n kh√¥ng c√≥, th·ª≠ l·∫•y t·ª´ localStorage m·ªôt l·∫ßn n·ªØa
                if (examInfo) {
                    try {
                        const savedExamData = JSON.parse(examInfo);
                        if (savedExamData.attempt_id && savedExamData.exam_id) {
                            attemptId = savedExamData.attempt_id;
                            examId = savedExamData.exam_id;
                            console.log('‚úÖ ƒê√£ l·∫•y exam_id v√† attempt_id t·ª´ localStorage:', { examId, attemptId });

                            // ‚≠ê C·∫¨P NH·∫¨T URL NGAY L·∫¨P T·ª®C n·∫øu URL c√≥ exam_id=null
                            const currentUrl = new URL(window.location.href);
                            const currentExamId = currentUrl.searchParams.get('exam_id');
                            const currentAttemptId = currentUrl.searchParams.get('attempt_id');

                            if (currentExamId === 'null' || currentExamId === null ||
                                currentAttemptId === 'null' || currentAttemptId === null ||
                                currentExamId !== String(examId) || currentAttemptId !== String(attemptId)) {
                                const newUrl = new URL(window.location.href);
                                newUrl.searchParams.set('exam_id', examId);
                                newUrl.searchParams.set('attempt_id', attemptId);
                                console.log('‚úÖ C·∫≠p nh·∫≠t URL t·ª´ null th√†nh:', newUrl.href);
                                window.history.replaceState({}, '', newUrl);
                            }
                        }
                    } catch (e) {
                        console.error('‚ùå L·ªói parse examInfo:', e);
                    }
                }

                // ‚≠ê N·∫æU V·∫™N KH√îNG C√ì exam_id ho·∫∑c attempt_id, REDIRECT V·ªÄ DASHBOARD
                if (!attemptId || !examId || examId === 'null' || attemptId === 'null') {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y exam_id ho·∫∑c attempt_id h·ª£p l·ªá!');
                    console.error('‚ùå examId:', examId, 'attemptId:', attemptId);
                    console.error('‚ùå examInfo t·ª´ localStorage:', examInfo);
                    alert('‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin b√†i thi! Vui l√≤ng quay l·∫°i trang ch·ªß.');
                    window.location.href = './student_dashboard.html';
                    return;
                }

                // N·∫øu v·∫´n kh√¥ng c√≥, d√πng localStorage ƒë·ªÉ load exam
                if (!attemptId || !examId) {
                    if (examInfo) {
                        try {
                            examData = JSON.parse(examInfo);
                            // QUAN TR·ªåNG: Reset answers v√† ch·ªâ load t·ª´ localStorage n·∫øu attempt_id V√Ä student_id kh·ªõp
                            answers = {};
                            const savedAttemptId = localStorage.getItem('current_attempt_id');
                            const savedStudentId = localStorage.getItem('current_student_id');

                            // ‚≠ê SECURITY FIX: Ch·ªâ load answers t·ª´ localStorage n·∫øu C·∫¢ attempt_id V√Ä student_id kh·ªõp
                            if (examData.attempt_id && savedAttemptId &&
                                String(examData.attempt_id) === String(savedAttemptId) &&
                                userId && savedStudentId && String(userId) === String(savedStudentId)) {
                                const savedAnswers = localStorage.getItem('exam_answers');
                                if (savedAnswers) {
                                    try {
                                        answers = JSON.parse(savedAnswers);
                                        console.log('‚úÖ [Security] Loaded answers - student_id & attempt_id matched');
                                    } catch (e) {
                                        console.error('‚ùå L·ªói parse saved answers:', e);
                                        answers = {};
                                    }
                                }
                            } else {
                                // N·∫øu attempt_id ho·∫∑c student_id kh√¥ng kh·ªõp, clear localStorage
                                console.warn('‚ö†Ô∏è [Security] Student ID ho·∫∑c Attempt ID kh√¥ng kh·ªõp, clear answers c≈©');
                                console.warn(`   userId: ${userId}, savedStudentId: ${savedStudentId}`);
                                console.warn(`   attemptId: ${examData.attempt_id}, savedAttemptId: ${savedAttemptId}`);
                                localStorage.removeItem('exam_answers');
                                localStorage.removeItem('current_attempt_id');
                                localStorage.removeItem('current_student_id');
                                answers = {};
                            }

                            // C·∫≠p nh·∫≠t URL n·∫øu c√≥ attempt_id v√† exam_id
                            // CH·ªà c·∫≠p nh·∫≠t n·∫øu URL hi·ªán t·∫°i kh√°c v·ªõi URL m·ªõi (tr√°nh trigger reload kh√¥ng c·∫ßn thi·∫øt)
                            if (examData.attempt_id && examData.exam_id) {
                                const currentUrl = new URL(window.location.href);
                                const currentExamId = currentUrl.searchParams.get('exam_id');
                                const currentAttemptId = currentUrl.searchParams.get('attempt_id');

                                if (currentExamId !== String(examData.exam_id) || currentAttemptId !== String(examData.attempt_id)) {
                                    const newUrl = new URL(window.location.href);
                                    newUrl.searchParams.set('exam_id', examData.exam_id);
                                    newUrl.searchParams.set('attempt_id', examData.attempt_id);
                                    window.history.replaceState({}, '', newUrl);
                                }
                            }
                        } catch (e) {
                            console.error('‚ùå L·ªói parse examInfo:', e);
                            alert('‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin b√†i thi! Vui l√≤ng quay l·∫°i trang ch·ªß.');
                            window.location.href = './student_dashboard.html';
                            return;
                        }
                    } else {
                        alert('‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin b√†i thi! Vui l√≤ng quay l·∫°i trang ch·ªß.');
                        window.location.href = './student_dashboard.html';
                        return;
                    }
                }
            }

            // ‚≠ê ƒê·∫¢M B·∫¢O examData ƒê∆Ø·ª¢C SET ƒê√öNG TR∆Ø·ªöC KHI TI·∫æP T·ª§C
            if (!examData || !examData.exam_id || !examData.attempt_id) {
                // N·∫øu ch∆∞a c√≥ examData, t·∫°o t·ª´ examId v√† attemptId
                if (examId && attemptId && examId !== 'null' && attemptId !== 'null') {
                    examData = {
                        exam_id: parseInt(examId),
                        attempt_id: parseInt(attemptId)
                    };
                    console.log('‚úÖ ƒê√£ t·∫°o examData t·ª´ URL:', examData);
                } else if (examInfo) {
                    // N·∫øu v·∫´n kh√¥ng c√≥, load t·ª´ localStorage
                    try {
                        examData = JSON.parse(examInfo);
                        console.log('‚úÖ ƒê√£ load examData t·ª´ localStorage:', examData);
                    } catch (e) {
                        console.error('‚ùå L·ªói parse examInfo t·ª´ localStorage:', e);
                        alert('‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin b√†i thi! Vui l√≤ng quay l·∫°i trang ch·ªß.');
                        window.location.href = './student_dashboard.html';
                        return;
                    }
                } else {
                    alert('‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin b√†i thi! Vui l√≤ng quay l·∫°i trang ch·ªß.');
                    window.location.href = './student_dashboard.html';
                    return;
                }
            }

            if (attemptId && examId && examId !== 'null' && attemptId !== 'null') {
                // Reload trang - c·∫ßn load l·∫°i attempt t·ª´ server ƒë·ªÉ l·∫•y start_time v√† ƒë√°p √°n ƒë√£ l∆∞u
                try {
                    const attemptData = await apiGet(`/api/student/exams/${examId}/attempt/${attemptId}`);

                    if (attemptData && attemptData.attempt) {
                        // C·∫≠p nh·∫≠t examData v·ªõi start_time t·ª´ server
                        examData = {
                            ...attemptData.exam,
                            attempt_id: parseInt(attemptId),
                            start_time: attemptData.attempt.start_time,
                            questions: attemptData.questions || []
                        };

                        // QUAN TR·ªåNG: Reset answers object ƒë·ªÉ tr√°nh d√πng answers c≈© t·ª´ attempt kh√°c
                        answers = {};

                        // Kh√¥i ph·ª•c ƒë√°p √°n ƒë√£ ch·ªçn t·ª´ server (CH·ªà t·ª´ server, kh√¥ng t·ª´ localStorage)
                        if (attemptData.questions) {
                            attemptData.questions.forEach(q => {
                                if (q.saved_answer !== null && q.saved_answer !== undefined) {
                                    if (q.question_type === 'MultipleChoice') {
                                        // MultipleChoice c√≥ th·ªÉ c√≥ nhi·ªÅu ƒë√°p √°n
                                        answers[q.question_id] = Array.isArray(q.saved_answer)
                                            ? q.saved_answer.map(a => String(a)) // Convert to string ƒë·ªÉ so s√°nh
                                            : [String(q.saved_answer)];
                                    } else {
                                        // SingleChoice ho·∫∑c TextAnswer - convert to string ƒë·ªÉ so s√°nh
                                        answers[q.question_id] = String(q.saved_answer);
                                    }
                                }
                            });
                        }

                        // ‚≠ê SECURITY FIX: L∆∞u l·∫°i v√†o localStorage v·ªõi C·∫¢ attempt_id V√Ä student_id
                        localStorage.setItem('current_exam', JSON.stringify(examData));
                        localStorage.setItem('exam_answers', JSON.stringify(answers));
                        localStorage.setItem('current_attempt_id', String(attemptId));
                        localStorage.setItem('current_student_id', String(userId));
                        console.log('‚úÖ [Security] Saved answers with student_id:', userId);
                    } else {
                        throw new Error('Kh√¥ng t√¨m th·∫•y attempt');
                    }
                } catch (error) {
                    console.error('‚ùå [Reload] L·ªói load attempt:', error);
                    // Fallback: d√πng localStorage
                    if (examInfo) {
                        examData = JSON.parse(examInfo);
                        // Kh√¥i ph·ª•c answers t·ª´ localStorage n·∫øu c√≥
                        const savedAnswers = localStorage.getItem('exam_answers');
                        if (savedAnswers) {
                            try {
                                answers = JSON.parse(savedAnswers);
                            } catch (e) {
                                console.error('‚ùå L·ªói parse saved answers:', e);
                            }
                        }
                    } else {
                        alert('‚ùå Kh√¥ng th·ªÉ load l·∫°i b√†i thi!');
                        window.location.href = './student_dashboard.html';
                        return;
                    }
                }
            } else {
                // L·∫ßn ƒë·∫ßu v√†o trang - l·∫•y t·ª´ localStorage
                if (!examInfo) {
                    alert('‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin b√†i thi!');
                    window.location.href = './student_dashboard.html';
                    return;
                }
                examData = JSON.parse(examInfo);

                // QUAN TR·ªåNG: Reset answers object v√† ch·ªâ load t·ª´ localStorage n·∫øu attempt_id V√Ä student_id kh·ªõp
                answers = {};
                const savedAttemptId = localStorage.getItem('current_attempt_id');
                const savedStudentId = localStorage.getItem('current_student_id');

                // ‚≠ê SECURITY FIX: Ch·ªâ load answers t·ª´ localStorage n·∫øu C·∫¢ attempt_id V√Ä student_id kh·ªõp
                if (examData.attempt_id && savedAttemptId &&
                    String(examData.attempt_id) === String(savedAttemptId) &&
                    userId && savedStudentId && String(userId) === String(savedStudentId)) {
                    const savedAnswers = localStorage.getItem('exam_answers');
                    if (savedAnswers) {
                        try {
                            answers = JSON.parse(savedAnswers);
                            console.log('‚úÖ [Security] Loaded answers - student_id & attempt_id matched');
                        } catch (e) {
                            console.error('‚ùå L·ªói parse saved answers:', e);
                            answers = {};
                        }
                    }
                } else {
                    // N·∫øu attempt_id ho·∫∑c student_id kh√¥ng kh·ªõp, clear localStorage
                    console.warn('‚ö†Ô∏è [Security] Student ID ho·∫∑c Attempt ID kh√¥ng kh·ªõp, clear answers c≈©');
                    console.warn(`   userId: ${userId}, savedStudentId: ${savedStudentId}`);
                    console.warn(`   attemptId: ${examData.attempt_id}, savedAttemptId: ${savedAttemptId}`);
                    localStorage.removeItem('exam_answers');
                    localStorage.removeItem('current_attempt_id');
                    localStorage.removeItem('current_student_id');
                    answers = {};
                }

                // C·∫≠p nh·∫≠t URL ƒë·ªÉ c√≥ attempt_id v√† exam_id
                // CH·ªà c·∫≠p nh·∫≠t n·∫øu URL hi·ªán t·∫°i kh√°c v·ªõi URL m·ªõi (tr√°nh trigger reload kh√¥ng c·∫ßn thi·∫øt)
                if (examData.attempt_id && examData.exam_id) {
                    const currentUrl = new URL(window.location.href);
                    const currentExamId = currentUrl.searchParams.get('exam_id');
                    const currentAttemptId = currentUrl.searchParams.get('attempt_id');

                    if (currentExamId !== String(examData.exam_id) || currentAttemptId !== String(examData.attempt_id)) {
                        const newUrl = new URL(window.location.href);
                        newUrl.searchParams.set('exam_id', examData.exam_id);
                        newUrl.searchParams.set('attempt_id', examData.attempt_id);
                        window.history.replaceState({}, '', newUrl);
                    }
                }
            }

            initSocket();
            initWebcam();
            initAntiCheating();
            loadExam();
            startTimer();
        });

        function initSocket() {
            // S·ª≠ d·ª•ng CONFIG.SOCKET_URL t·ª´ config.js
            socket = io(window.CONFIG?.SOCKET_URL || window.location.origin, {
                auth: { token }
            });

            // ‚≠ê INTERCEPT WEBSOCKET MESSAGES TR·ª∞C TI·∫æP (low-level)
            if (socket.io && socket.io.engine && socket.io.engine.transport) {
                const transport = socket.io.engine.transport;
                if (transport.socket) {
                    const originalOnMessage = transport.socket.onmessage;
                    transport.socket.onmessage = function (event) {
                        const msgId = `ws_msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        console.log(`üîµ [WebSocket] [${msgId}] Raw message received:`, event.data);
                        console.log(`üîµ [WebSocket] [${msgId}] Message stack:`, new Error().stack);

                        // ‚≠ê KI·ªÇM TRA V√Ä BLOCK T·∫§T C·∫¢ MESSAGES C√ì TH·ªÇ G√ÇY RELOAD
                        let shouldBlock = false;
                        try {
                            const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
                            if (data && (
                                data.type === 'reload' ||
                                data.action === 'reload' ||
                                data.reload === true ||
                                data.type === 'redirect' ||
                                data.action === 'redirect' ||
                                data.redirect === true ||
                                data.command === 'reload' ||
                                data.command === 'redirect'
                            )) {
                                console.error(`üî¥ [WebSocket] [${msgId}] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è PH√ÅT HI·ªÜN MESSAGE G√ÇY RELOAD/REDIRECT - ƒê√É BLOCK!`, data);
                                shouldBlock = true;
                            }
                        } catch (e) {
                            // Kh√¥ng ph·∫£i JSON, ki·ªÉm tra string
                            if (typeof event.data === 'string') {
                                const dataStr = event.data.toLowerCase();
                                if (dataStr.includes('reload') ||
                                    dataStr.includes('redirect') ||
                                    dataStr.includes('location.reload') ||
                                    dataStr.includes('window.location') ||
                                    dataStr.includes('location.href')) {
                                    console.error(`üî¥ [WebSocket] [${msgId}] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è PH√ÅT HI·ªÜN STRING MESSAGE G√ÇY RELOAD - ƒê√É BLOCK!`, event.data);
                                    shouldBlock = true;
                                }
                            }
                        }

                        // ‚≠ê BLOCK MESSAGE N√ÄY HO√ÄN TO√ÄN
                        if (shouldBlock) {
                            return; // KH√îNG g·ªçi originalOnMessage
                        }

                        return originalOnMessage.call(this, event);
                    };
                }
            }

            // ‚≠ê LOG T·∫§T C·∫¢ SOCKET EVENTS ƒë·ªÉ debug
            const socketOriginalEmit = socket.emit.bind(socket);
            socket.emit = function (event, ...args) {
                console.log(`üîµ [Socket] Emitting: ${event}`, args);
                return socketOriginalEmit(event, ...args);
            };

            socket.on('connect', () => {
                console.log('üîµ [Socket] Connected');
                socket.emit('join', `user_${userId}`);
                socket.emit('join_exam', {
                    exam_id: examData.exam_id,
                    attempt_id: examData.attempt_id
                });
            });

            // ‚≠ê LOG T·∫§T C·∫¢ SOCKET EVENTS NH·∫¨N ƒê∆Ø·ª¢C
            socket.onAny((eventName, ...args) => {
                const eventId = `socket_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                console.log(`üîµ [Socket] [${eventId}] Received event: ${eventName}`, args);
                console.log(`üîµ [Socket] [${eventId}] Event stack:`, new Error().stack);

                // ‚ö†Ô∏è C·∫¢NH B√ÅO N·∫æU EVENT C√ì TH·ªÇ G√ÇY RELOAD
                if (eventName.includes('reload') || eventName.includes('redirect') || eventName.includes('ban')) {
                    console.error(`üî¥ [Socket] [${eventId}] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è PH√ÅT HI·ªÜN EVENT C√ì TH·ªÇ G√ÇY RELOAD: ${eventName}`);
                }
            });

            // ‚≠ê INTERCEPT SOCKET.IO INTERNAL MESSAGES (n·∫øu c√≥)
            const socketOriginalOn = socket.on.bind(socket);

            // Wrap socket.on ƒë·ªÉ log t·∫•t c·∫£ handlers
            socket.on = function (eventName, handler) {
                console.log(`üîµ [Socket] Registering handler for event: ${eventName}`);
                return socketOriginalOn(eventName, function (...args) {
                    const handlerId = `handler_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    console.log(`üîµ [Socket] [${handlerId}] Handler called for: ${eventName}`, args);
                    console.log(`üîµ [Socket] [${handlerId}] Handler stack:`, new Error().stack);
                    try {
                        const result = handler.apply(this, args);
                        console.log(`üîµ [Socket] [${handlerId}] Handler completed`);
                        return result;
                    } catch (error) {
                        console.error(`üî¥ [Socket] [${handlerId}] Handler error:`, error);
                        console.error(`üî¥ [Socket] [${handlerId}] Handler error stack:`, error.stack);
                        throw error;
                    }
                });
            };

            socket.on('exam_banned', (data) => {
                console.error('üîµ [Socket] exam_banned event received:', data);
                alert(`‚õî B·∫°n ƒë√£ b·ªã c·∫•m thi!\nL√Ω do: ${data.reason}`);
                window.location.href = './student_dashboard.html';
            });

            socket.on('points_deducted', (data) => {
                console.log('üîµ [Socket] points_deducted event received:', data);
                showToast(`‚ö†Ô∏è B·∫°n ƒë√£ b·ªã tr·ª´ ${data.points_deducted} ƒëi·ªÉm!\nL√Ω do: ${data.reason}`, 'warning');
            });

            socket.on('answerSaved', (data) => {
                console.log('üîµ [Socket] answerSaved event received:', data);
                // ƒê√°p √°n ƒë√£ ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông
            });

            socket.on('disconnect', (reason) => {
                console.log('üîµ [Socket] Disconnected, reason:', reason);
            });

            // ‚≠ê CATCH T·∫§T C·∫¢ SOCKET ERRORS
            socket.on('error', (error) => {
                console.error('üîµ [Socket] Error:', error);
                console.error('üîµ [Socket] Error stack:', new Error().stack);
            });

            socket.on('connect_error', (error) => {
                console.error('üîµ [Socket] Connect error:', error);
                console.error('üîµ [Socket] Connect error stack:', new Error().stack);
            });
        }

        async function initWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    },
                    audio: false
                });

                const videoElement = document.getElementById('localVideo');
                videoElement.srcObject = stream;
                document.getElementById('webcamStatus').textContent = 'üü¢ ƒêang gi√°m s√°t';
                document.getElementById('webcamStatus').style.background = '#26de81';

                // L∆∞u attempt_id v√†o global ƒë·ªÉ AI module c√≥ th·ªÉ d√πng
                window.currentAttemptId = examData.attempt_id;
                window.examData = examData;

                // Kh·ªüi t·∫°o AI detection
                await initAIDetection(videoElement, stream);

            } catch (error) {
                console.error('‚ùå Webcam error:', error);
                document.getElementById('webcamStatus').textContent = '‚ùå L·ªói camera';
                document.getElementById('webcamStatus').style.background = '#ff4757';

                logCheating('WebcamSuspicious', 'Kh√¥ng th·ªÉ truy c·∫≠p webcam');

                if (!confirm('‚ùå Kh√¥ng th·ªÉ b·∫≠t camera!\nB·∫°n c√≥ mu·ªën ti·∫øp t·ª•c?')) {
                    window.location.href = './student_dashboard.html';
                }
            }
        }

        // Kh·ªüi t·∫°o AI ph√°t hi·ªán gian l·∫≠n
        async function initAIDetection(videoElement, stream) {
            try {

                // T·∫°o instance AI detection
                aiDetection = new AICheatingDetection({
                    videoElement: videoElement,
                    detectionInterval: 3000, // TƒÉng l√™n 3 gi√¢y ƒë·ªÉ gi·∫£m lag
                    onViolationDetected: async (violation) => {
                        const callbackId = `callback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        console.warn(`üîç [DEBUG] [${callbackId}] onViolationDetected START:`, violation);
                        console.warn(`üîç [DEBUG] [${callbackId}] Callback stack:`, new Error().stack);

                        try {
                            // Ghi log vi ph·∫°m - KH√îNG await ƒë·ªÉ kh√¥ng block UI
                            // Ch·∫°y trong background, kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn vi·ªác l√†m b√†i
                            console.log(`üîç [DEBUG] [${callbackId}] Calling logCheating...`);
                            const logPromise = logCheating(violation.type, violation.description);
                            if (logPromise && typeof logPromise.catch === 'function') {
                                logPromise.catch(logError => {
                                    console.error(`‚ùå [DEBUG] [${callbackId}] L·ªói ghi log:`, logError);
                                    console.error(`‚ùå [DEBUG] [${callbackId}] Log error stack:`, logError.stack);
                                    // Kh√¥ng throw error ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn UI
                                });
                            }
                            console.log(`üîç [DEBUG] [${callbackId}] logCheating ƒë√£ ƒë∆∞·ª£c g·ªçi (kh√¥ng await)`);

                            // Hi·ªÉn th·ªã c·∫£nh b√°o
                            console.log(`üîç [DEBUG] [${callbackId}] Calling showWarning...`);
                            try {
                                showWarning(`‚ö†Ô∏è C·∫£nh b√°o: ${violation.description}`);
                                console.log(`üîç [DEBUG] [${callbackId}] showWarning OK`);
                            } catch (showWarningError) {
                                console.error(`‚ùå [DEBUG] [${callbackId}] L·ªói showWarning:`, showWarningError);
                            }

                            // G·ª≠i socket alert - KH√îNG await ƒë·ªÉ kh√¥ng block
                            if (socket) {
                                console.log(`üîç [DEBUG] [${callbackId}] Sending socket alert...`);
                                try {
                                    socket.emit('cheating_alert', {
                                        exam_id: examData.exam_id,
                                        attempt_id: examData.attempt_id,
                                        student_id: userId,
                                        event_type: violation.type,
                                        event_description: violation.description
                                    });
                                    console.log(`üîç [DEBUG] [${callbackId}] Socket alert sent OK`);
                                } catch (socketError) {
                                    console.warn(`‚ö†Ô∏è [DEBUG] [${callbackId}] L·ªói g·ª≠i alert:`, socketError);
                                    console.warn(`‚ö†Ô∏è [DEBUG] [${callbackId}] Socket error stack:`, socketError.stack);
                                }
                            } else {
                                console.warn(`‚ö†Ô∏è [DEBUG] [${callbackId}] Socket kh√¥ng c√≥`);
                            }

                            console.log(`üîç [DEBUG] [${callbackId}] onViolationDetected END`);
                        } catch (callbackError) {
                            console.error(`‚ùå [DEBUG] [${callbackId}] L·ªói trong onViolationDetected (sync):`, callbackError);
                            console.error(`‚ùå [DEBUG] [${callbackId}] Callback error stack:`, callbackError.stack);
                            // KH√îNG throw - ch·ªâ log
                        }
                    },
                    onVideoReady: () => {
                    }
                });

                // Load AI models (c√≥ th·ªÉ m·∫•t v√†i gi√¢y)
                const modelsLoaded = await aiDetection.initialize();

                if (modelsLoaded) {
                    // B·∫Øt ƒë·∫ßu ph√°t hi·ªán v·ªõi AI models
                    await aiDetection.startDetection(stream);
                    document.getElementById('webcamStatus').textContent = 'ü§ñ AI ƒêang gi√°m s√°t';
                } else {
                    // Fallback: d√πng ph√°t hi·ªán ƒë∆°n gi·∫£n
                    await aiDetection.startDetection(stream);
                    document.getElementById('webcamStatus').textContent = 'üìπ ƒêang gi√°m s√°t';
                }

            } catch (error) {
                console.error('‚ùå L·ªói kh·ªüi t·∫°o AI detection:', error);
                // Ti·∫øp t·ª•c v·ªõi ph√°t hi·ªán c∆° b·∫£n
            }
        }

        function initAntiCheating() {
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    tabSwitchCount++;
                    updateTabSwitchWarning();
                    logCheating('TabSwitch', `Chuy·ªÉn tab l·∫ßn ${tabSwitchCount}`);

                    showWarning(`‚ö†Ô∏è C·∫£nh b√°o: Kh√¥ng ƒë∆∞·ª£c chuy·ªÉn tab! (${tabSwitchCount}/3)`);

                    if (tabSwitchCount >= 3) {
                        socket.emit('cheating_alert', {
                            exam_id: examData.exam_id,
                            attempt_id: examData.attempt_id,
                            student_id: userId,
                            event_type: 'TabSwitch',
                            event_description: `V∆∞·ª£t ng∆∞·ª°ng: ${tabSwitchCount} l·∫ßn`
                        });
                    }
                }
            });

            document.addEventListener('copy', (e) => {
                e.preventDefault();
                logCheating('CopyPaste', 'C·ªë g·∫Øng copy');
                showToast('‚ùå Kh√¥ng ƒë∆∞·ª£c ph√©p copy!', 'error');
            });

            document.addEventListener('paste', (e) => {
                e.preventDefault();
                logCheating('CopyPaste', 'C·ªë g·∫Øng paste');
                showToast('‚ùå Kh√¥ng ƒë∆∞·ª£c ph√©p paste!', 'error');
            });

            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showToast('‚ùå Kh√¥ng ƒë∆∞·ª£c ph√©p chu·ªôt ph·∫£i!', 'error');
            });

            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey && e.shiftKey && e.key === 'I') ||
                    (e.ctrlKey && e.key === 'u')) {
                    e.preventDefault();
                    logCheating('DevTools', 'C·ªë g·∫Øng m·ªü DevTools');
                    showToast('‚ùå Kh√¥ng ƒë∆∞·ª£c m·ªü c√¥ng c·ª• ph√°t tri·ªÉn!', 'error');
                }
            });

            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(() => {
                    // Fullscreen kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£
                });
            }
        }

        function updateTabSwitchWarning() {
            const el = document.getElementById('tabSwitchWarning');
            el.textContent = `Chuy·ªÉn tab: ${tabSwitchCount}/3`;
            if (tabSwitchCount >= 2) {
                el.style.color = '#ff4757';
                el.style.fontWeight = 'bold';
            }
        }

        async function logCheating(eventType, description) {
            const logId = `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            console.log(`üîç [DEBUG] [${logId}] logCheating START: ${eventType} - ${description}`);
            console.log(`üîç [DEBUG] [${logId}] logCheating stack:`, new Error().stack);

            try {
                // Ki·ªÉm tra examData v√† attempt_id
                if (!examData || !examData.exam_id || !examData.attempt_id) {
                    console.error(`‚ùå [DEBUG] [${logId}] Thi·∫øu examData ho·∫∑c attempt_id:`, examData);
                    return null; // Tr·∫£ v·ªÅ null thay v√¨ undefined
                }
                console.log(`üîç [DEBUG] [${logId}] examData OK:`, { exam_id: examData.exam_id, attempt_id: examData.attempt_id });

                // S·ª≠ d·ª•ng apiPost t·ª´ api.js - wrap trong try-catch ƒë·ªÉ tr√°nh throw
                try {
                    console.log(`üîç [DEBUG] [${logId}] Calling apiPost...`);
                    const result = await apiPost(`/api/student/exams/${examData.exam_id}/cheating-log`, {
                        attempt_id: examData.attempt_id,
                        event_type: eventType,
                        event_description: description
                    });
                    console.log(`üîç [DEBUG] [${logId}] apiPost SUCCESS:`, result);
                    return result;
                } catch (apiError) {
                    // B·∫Øt l·ªói t·ª´ apiPost v√† log, KH√îNG throw
                    console.error(`‚ùå [DEBUG] [${logId}] L·ªói API:`, apiError);
                    console.error(`‚ùå [DEBUG] [${logId}] API error message:`, apiError.message);
                    console.error(`‚ùå [DEBUG] [${logId}] API error stack:`, apiError.stack);
                    console.error(`‚ùå [DEBUG] [${logId}] API error details:`, {
                        message: apiError.message,
                        name: apiError.name,
                        stack: apiError.stack,
                        data: apiError.data,
                        response: apiError.response
                    });
                    // Tr·∫£ v·ªÅ null thay v√¨ throw ƒë·ªÉ kh√¥ng g√¢y unhandled rejection
                    return null;
                }
            } catch (error) {
                console.error(`‚ùå [DEBUG] [${logId}] L·ªói ghi log (sync):`, error);
                console.error(`‚ùå [DEBUG] [${logId}] Error details:`, {
                    message: error.message,
                    data: error.data,
                    exam_id: examData?.exam_id,
                    attempt_id: examData?.attempt_id
                });
                // KH√îNG throw - tr·∫£ v·ªÅ null ƒë·ªÉ kh√¥ng g√¢y unhandled rejection
                return null;
            }
        }

        function loadExam() {
            document.getElementById('examTitle').textContent = examData.exam_name;

            const questions = examData.questions;

            // Ki·ªÉm tra v√† log ƒë·ªÉ debug
            if (!questions || questions.length === 0) {
                console.error('‚ùå [loadExam] Kh√¥ng c√≥ c√¢u h·ªèi!');
                document.getElementById('questionContainer').innerHTML =
                    '<div style="color: red; padding: 20px; text-align: center;">‚ö†Ô∏è L·ªói: Kh√¥ng c√≥ c√¢u h·ªèi. Vui l√≤ng reload trang.</div>';
                return;
            }

            // Ki·ªÉm tra xem questions c√≥ options kh√¥ng
            questions.forEach((q, i) => {
                if (!q.options || !Array.isArray(q.options) || q.options.length === 0) {
                    console.error(`‚ùå [loadExam] Question ${i + 1} (ID: ${q.question_id}) kh√¥ng c√≥ options:`, q);
                }
            });

            const nav = document.getElementById('questionNav');

            nav.innerHTML = questions.map((q, i) =>
                `<button class="question-nav-btn" data-index="${i}" onclick="goToQuestion(${i})">${i + 1}</button>`
            ).join('');

            updateProgress();
            showQuestion(0);
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë√£ tr·∫£ l·ªùi sau khi load exam
            updateAnsweredStatus();
        }

        function showQuestion(index) {
            if (index < 0 || index >= examData.questions.length) return;

            currentQuestionIndex = index;
            const question = examData.questions[index];

            const container = document.getElementById('questionContainer');

            let optionsHTML = '';

            // X·ª≠ l√Ω Essay v√† FillInBlank tr∆∞·ªõc (kh√¥ng c·∫ßn options)
            if (question.question_type === 'Essay' || question.question_type === 'FillInBlank') {
                optionsHTML = `<textarea class="textarea-answer" id="textAnswer" placeholder="Nh·∫≠p c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n...">${answers[question.question_id] || ''}</textarea>`;
            } else if (question.question_type === 'SingleChoice') {
                // Ki·ªÉm tra c√≥ options kh√¥ng
                if (!question.options || !Array.isArray(question.options) || question.options.length === 0) {
                    console.error('‚ùå [showQuestion] Question kh√¥ng c√≥ options:', question);
                    optionsHTML = '<div style="color: red; padding: 20px; text-align: center;">‚ö†Ô∏è L·ªói: C√¢u h·ªèi kh√¥ng c√≥ ƒë√°p √°n. Vui l√≤ng li√™n h·ªá gi√°o vi√™n.</div>';
                } else {
                    // Ki·ªÉm tra answers c√≥ gi√° tr·ªã kh√¥ng (c√≥ th·ªÉ l√† s·ªë ho·∫∑c string)
                    const selectedAnswer = answers[question.question_id];
                    optionsHTML = question.options.map((opt, i) => {
                        // So s√°nh linh ho·∫°t (== thay v√¨ === ƒë·ªÉ x·ª≠ l√Ω string vs number)
                        const isChecked = selectedAnswer !== undefined && selectedAnswer !== null &&
                            (selectedAnswer == opt.option_id || String(selectedAnswer) === String(opt.option_id));
                        return `
                <div class="option ${isChecked ? 'selected' : ''}" onclick="selectOption(${i})">
                    <input type="radio" name="answer_${question.question_id}" value="${opt.option_id}" 
                           ${isChecked ? 'checked' : ''}>
                    <span>${String.fromCharCode(65 + i)}. ${opt.option_content}</span>
                </div>
            `;
                    }).join('');
                }
            } else if (question.question_type === 'MultipleChoice') {
                // Ki·ªÉm tra c√≥ options kh√¥ng
                if (!question.options || !Array.isArray(question.options) || question.options.length === 0) {
                    console.error('‚ùå [showQuestion] Question kh√¥ng c√≥ options:', question);
                    optionsHTML = '<div style="color: red; padding: 20px; text-align: center;">‚ö†Ô∏è L·ªói: C√¢u h·ªèi kh√¥ng c√≥ ƒë√°p √°n. Vui l√≤ng li√™n h·ªá gi√°o vi√™n.</div>';
                } else {
                    const savedAnswers = answers[question.question_id] || [];
                    // ƒê·∫£m b·∫£o savedAnswers l√† m·∫£ng v√† convert sang string ƒë·ªÉ so s√°nh
                    const answersArray = Array.isArray(savedAnswers) ? savedAnswers.map(a => String(a)) : [String(savedAnswers)].filter(Boolean);
                    optionsHTML = question.options.map((opt, i) => {
                        const optIdStr = String(opt.option_id);
                        const isChecked = answersArray.some(a => String(a) === optIdStr);
                        return `
                    <div class="option ${isChecked ? 'selected' : ''}" onclick="toggleOption(${i})">
                        <input type="checkbox" name="answer_${question.question_id}" value="${opt.option_id}"
                               ${isChecked ? 'checked' : ''}>
                        <span>${String.fromCharCode(65 + i)}. ${opt.option_content}</span>
                    </div>
                `;
                    }).join('');
                }
            } else {
                // Fallback cho c√°c lo·∫°i c√¢u h·ªèi kh√°c
                optionsHTML = `<textarea class="textarea-answer" id="textAnswer" placeholder="Nh·∫≠p c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n...">${answers[question.question_id] || ''}</textarea>`;
            }

            container.innerHTML = `
            <div class="question-meta">
                <span class="meta-badge">C√¢u ${index + 1}/${examData.questions.length}</span>
                <span class="meta-badge">${question.question_type}</span>
                <span class="meta-badge">${question.difficulty}</span>
                <span class="meta-badge">${question.points} ƒëi·ªÉm</span>
            </div>
            <div class="question-text">${question.question_content}</div>
            <div class="options">${optionsHTML}</div>
        `;

            document.querySelectorAll('.question-nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.querySelector(`.question-nav-btn[data-index="${index}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            document.getElementById('prevBtn').disabled = (index === 0);
            document.getElementById('nextBtn').disabled = (index === examData.questions.length - 1);

            updateProgress();
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë√£ tr·∫£ l·ªùi sau khi render
            updateAnsweredStatus();
        }

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        function isExamActive() {
            const currentTime = Date.now();
            const startTime = new Date(examData.start_time).getTime();
            const durationMs = examData.duration * 60 * 1000;
            return currentTime >= startTime && currentTime <= startTime + durationMs;
        }

        const autoSaveAnswer = debounce(async (questionId, answerText, optionId = null) => {
            if (!isExamActive()) {
                showToast('‚è∞ B√†i thi ƒë√£ h·∫øt gi·ªù! Kh√¥ng th·ªÉ l∆∞u ƒë√°p √°n.', 'error');
                return;
            }

            try {
                // S·ª≠ d·ª•ng apiPost t·ª´ api.js - t·ª± ƒë·ªông x·ª≠ l√Ω errors
                await apiPost(`/api/student/exams/${examData.exam_id}/save-answer`, {
                    attempt_id: examData.attempt_id,
                    question_id: questionId,
                    answer_text: answerText,
                    option_id: optionId
                });

                updateAnsweredStatus();
            } catch (error) {
                console.error('‚ùå Error saving answer:', error);
                showToast(`‚ùå L·ªói: ${error.message}`, 'error');
            }
        }, 500);

        async function selectOption(index) {
            const question = examData.questions[currentQuestionIndex];
            const options = document.querySelectorAll('.option');

            options.forEach(opt => opt.classList.remove('selected'));
            options[index].classList.add('selected');
            options[index].querySelector('input').checked = true;

            const optionId = question.options[index].option_id;
            answers[question.question_id] = optionId;
            updateAnsweredStatus();

            await autoSaveAnswer(question.question_id, null, optionId);
        }

        async function toggleOption(index) {
            const question = examData.questions[currentQuestionIndex];
            const option = document.querySelectorAll('.option')[index];
            const checkbox = option.querySelector('input');

            checkbox.checked = !checkbox.checked;
            option.classList.toggle('selected');

            if (!answers[question.question_id]) answers[question.question_id] = [];

            const optionId = question.options[index].option_id;
            if (checkbox.checked) {
                answers[question.question_id].push(optionId);
            } else {
                answers[question.question_id] = answers[question.question_id].filter(a => a !== optionId);
            }

            updateAnsweredStatus();
            await autoSaveAnswer(question.question_id, answers[question.question_id].join(','), null);
        }

        function updateAnsweredStatus() {
            document.querySelectorAll('.question-nav-btn').forEach((btn, i) => {
                const questionId = examData.questions[i].question_id;
                if (answers[questionId]) {
                    btn.classList.add('answered');
                }
            });
        }

        function updateProgress() {
            const answered = Object.keys(answers).filter(id => {
                const answer = answers[id];
                return answer !== null && answer !== undefined && (Array.isArray(answer) ? answer.length > 0 : answer !== '');
            }).length;
            const total = examData.questions.length;
            document.getElementById('questionProgress').textContent = `${answered}/${total} c√¢u`;
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                showQuestion(currentQuestionIndex - 1);
            }
        }

        function nextQuestion() {
            if (currentQuestionIndex < examData.questions.length - 1) {
                showQuestion(currentQuestionIndex + 1);
            }
        }

        function goToQuestion(index) {
            showQuestion(index);
        }

        function startTimer() {
            // T√≠nh th·ªùi gian c√≤n l·∫°i d·ª±a tr√™n start_time t·ª´ database (kh√¥ng reset khi reload)
            if (examData.start_time) {
                const startTime = new Date(examData.start_time).getTime();
                const durationMs = examData.duration * 60 * 1000;
                const endTime = startTime + durationMs;
                const currentTime = Date.now();

                // T√≠nh th·ªùi gian c√≤n l·∫°i (gi√¢y)
                timeRemaining = Math.max(0, Math.floor((endTime - currentTime) / 1000));

                console.log('‚è∞ [Timer] Kh·ªüi t·∫°o timer:', {
                    start_time: examData.start_time,
                    duration: examData.duration,
                    current_time: new Date(currentTime).toISOString(),
                    end_time: new Date(endTime).toISOString(),
                    time_remaining: timeRemaining
                });
            } else {
                // Fallback: n·∫øu kh√¥ng c√≥ start_time, d√πng duration (l·∫ßn ƒë·∫ßu v√†o trang)
                const duration = examData.duration;
                timeRemaining = duration * 60;
            }

            timerInterval = setInterval(() => {
                timeRemaining--;

                const hours = Math.floor(timeRemaining / 3600);
                const minutes = Math.floor((timeRemaining % 3600) / 60);
                const seconds = timeRemaining % 60;

                const timerEl = document.getElementById('timer');
                timerEl.textContent =
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                if (timeRemaining === 300) {
                    timerEl.classList.add('warning');
                    showToast('‚è∞ C√≤n 5 ph√∫t!', 'warning');
                }

                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    showToast('‚è∞ H·∫øt gi·ªù! ƒêang t·ª± ƒë·ªông n·ªôp b√†i...', 'error');
                    setTimeout(submitExam, 2000);
                }
            }, 1000);
        }

        async function saveAnswerDirect(questionId, answerText, optionId = null) {
            if (!isExamActive()) {
                showToast('‚è∞ B√†i thi ƒë√£ h·∫øt gi·ªù! Kh√¥ng th·ªÉ l∆∞u ƒë√°p √°n.', 'error');
                return Promise.reject(new Error('H·∫øt gi·ªù'));
            }

            try {
                // S·ª≠ d·ª•ng apiPost t·ª´ api.js - t·ª± ƒë·ªông x·ª≠ l√Ω errors
                const result = await apiPost(`/api/student/exams/${examData.exam_id}/save-answer`, {
                    attempt_id: examData.attempt_id,
                    question_id: questionId,
                    answer_text: answerText,
                    option_id: optionId
                });

                return result;
            } catch (error) {
                console.error('‚ùå Error saving answer:', error);
                throw error;
            }
        }

        // Ki·ªÉm tra c√¢u h·ªèi ch∆∞a l√†m
        function getUnansweredQuestions() {
            const unanswered = [];
            examData.questions.forEach((question, index) => {
                const questionId = question.question_id;
                const answer = answers[questionId];
                const hasAnswer = answer !== null && answer !== undefined &&
                    (Array.isArray(answer) ? answer.length > 0 : answer !== '');
                if (!hasAnswer) {
                    unanswered.push({
                        index: index + 1,
                        question_id: questionId,
                        question_content: question.question_content.substring(0, 100) + (question.question_content.length > 100 ? '...' : '')
                    });
                }
            });
            return unanswered;
        }

        // Hi·ªÉn th·ªã modal c·∫£nh b√°o c√¢u h·ªèi ch∆∞a l√†m
        function showUnansweredWarning(unansweredQuestions) {
            const modal = document.getElementById('unansweredWarningModal');
            const content = document.getElementById('unansweredWarningContent');

            content.innerHTML = `
            <div style="background: #fff5f5; border-left: 4px solid #f56565; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <p style="font-size: 16px; font-weight: 600; color: #742a2a; margin-bottom: 10px;">
                    ‚ö†Ô∏è B·∫°n c√≤n <strong>${unansweredQuestions.length}</strong> c√¢u h·ªèi ch∆∞a tr·∫£ l·ªùi!
                </p>
                <p style="color: #4a5568; margin-bottom: 15px; font-size: 14px;">
                    N·∫øu b·∫°n n·ªôp b√†i ngay b√¢y gi·ªù, c√°c c√¢u h·ªèi ch∆∞a tr·∫£ l·ªùi s·∫Ω ƒë∆∞·ª£c t√≠nh l√† <strong>sai</strong> v√† b·∫°n s·∫Ω <strong>m·∫•t ƒëi·ªÉm</strong>.
                </p>
            </div>
            <div style="text-align: left; margin-bottom: 15px;">
                <p style="font-weight: 600; margin-bottom: 10px; color: #2d3748;">Danh s√°ch c√¢u h·ªèi ch∆∞a tr·∫£ l·ªùi:</p>
                <div class="unanswered-list">
                    ${unansweredQuestions.map(q => `
                        <div class="unanswered-item">
                            <strong style="color: #667eea;">C√¢u ${q.index}:</strong>
                            <span style="color: #4a5568;">${q.question_content}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
            <div style="background: #e6fffa; border-left: 4px solid #38b2ac; padding: 15px; border-radius: 8px; display: flex; align-items: start; gap: 8px;">
                <span style="font-size: 20px; flex-shrink: 0;">üí°</span>
                <p style="color: #234e52; font-size: 14px; margin: 0;">
                    <strong>G·ª£i √Ω:</strong> B·∫°n c√≥ th·ªÉ quay l·∫°i l√†m c√°c c√¢u h·ªèi n√†y tr∆∞·ªõc khi n·ªôp b√†i ƒë·ªÉ ƒë·∫°t ƒëi·ªÉm cao h∆°n.
                </p>
            </div>
        `;

            modal.style.display = 'flex';
        }

        // ƒê√≥ng modal c·∫£nh b√°o
        function closeUnansweredModal() {
            document.getElementById('unansweredWarningModal').style.display = 'none';
        }

        // X√°c nh·∫≠n n·ªôp b√†i d√π c√≤n c√¢u h·ªèi ch∆∞a l√†m
        function confirmSubmitWithUnanswered() {
            closeUnansweredModal();
            // G·ªçi submitExam th·ª±c s·ª±
            submitExamActual();
        }

        // Function n·ªôp b√†i th·ª±c s·ª± (ƒë√£ ki·ªÉm tra)
        async function submitExamActual() {
            // D·ª´ng AI detection tr∆∞·ªõc khi n·ªôp b√†i
            if (aiDetection) {
                aiDetection.stopDetection();
            }
            if (!isExamActive()) {
                showToast('‚è∞ B√†i thi ƒë√£ h·∫øt gi·ªù! ƒêang n·ªôp b√†i t·ª± ƒë·ªông...', 'warning');
            }

            clearInterval(timerInterval);
            showToast('üíæ ƒêang l∆∞u c√¢u tr·∫£ l·ªùi...', 'info');

            try {
                const savePromises = [];
                const failedQuestions = [];

                for (const question of examData.questions) {
                    if (answers[question.question_id]) {
                        const answerText = question.question_type === 'MultipleChoice'
                            ? (Array.isArray(answers[question.question_id])
                                ? answers[question.question_id].join(',')
                                : answers[question.question_id])
                            : question.question_type === 'SingleChoice'
                                ? null
                                : answers[question.question_id];
                        const optionId = question.question_type === 'SingleChoice'
                            ? answers[question.question_id]
                            : null;

                        savePromises.push(
                            saveAnswerDirect(question.question_id, answerText, optionId)
                                .catch(error => {
                                    console.error(`‚ùå L·ªói l∆∞u c√¢u ${question.question_id}:`, error);
                                    failedQuestions.push(question.question_id);
                                    throw error;
                                })
                        );
                    }
                }

                await Promise.all(savePromises);

                if (failedQuestions.length > 0) {
                    showToast(`‚ùå L·ªói khi l∆∞u c√°c c√¢u: ${failedQuestions.join(', ')}`, 'error');
                    return;
                }

                // S·ª≠ d·ª•ng apiPost t·ª´ api.js - t·ª± ƒë·ªông x·ª≠ l√Ω errors
                const result = await apiPost(`/api/student/exams/${examData.exam_id}/submit`, {
                    attempt_id: examData.attempt_id
                });

                localStorage.removeItem('current_exam');
                // Ki·ªÉm tra n·∫øu c√≥ c√¢u t·ª± lu·∫≠n ch∆∞a ch·∫•m
                const hasPendingGrading = (result.has_essay_questions && !result.is_fully_graded) || !result.is_fully_graded;
                // S·ª≠ d·ª•ng total_points t·ª´ server response thay v√¨ examData
                showSubmitModal(result.score, result.total_points || examData.total_points || 100, result.message, hasPendingGrading);
            } catch (error) {
                console.error('‚ùå Error:', error);
                showToast(`‚ùå L·ªói: ${error.message}\nVui l√≤ng th·ª≠ l·∫°i!`, 'error');
            }
        }

        // Function n·ªôp b√†i (c√≥ ki·ªÉm tra c√¢u h·ªèi ch∆∞a l√†m)
        async function submitExam() {
            // Ki·ªÉm tra c√¢u h·ªèi ch∆∞a l√†m
            const unansweredQuestions = getUnansweredQuestions();

            // N·∫øu c√≥ c√¢u h·ªèi ch∆∞a l√†m, hi·ªÉn th·ªã c·∫£nh b√°o
            if (unansweredQuestions.length > 0) {
                showUnansweredWarning(unansweredQuestions);
                return; // D·ª´ng l·∫°i, ch·ªù h·ªçc sinh x√°c nh·∫≠n
            }

            // N·∫øu kh√¥ng c√≥ c√¢u h·ªèi ch∆∞a l√†m, h·ªèi x√°c nh·∫≠n b√¨nh th∆∞·ªùng
            if (!confirm('üì§ B·∫°n c√≥ ch·∫Øc mu·ªën n·ªôp b√†i?\n(Kh√¥ng th·ªÉ l√†m l·∫°i sau khi n·ªôp)')) {
                return;
            }

            // G·ªçi submitExam th·ª±c s·ª±
            submitExamActual();
        }

        function showSubmitModal(score, totalPoints, message, hasPendingGrading = false) {
            const modal = document.getElementById('submitModal');
            const modalScore = document.getElementById('modalScore');
            const modalMessage = document.getElementById('modalMessage');

            // N·∫øu c√≥ c√¢u t·ª± lu·∫≠n ch∆∞a ch·∫•m, kh√¥ng hi·ªÉn th·ªã ƒëi·ªÉm
            if (hasPendingGrading) {
                modalScore.innerHTML = `
                <div style="font-size: 24px; font-weight: 600; color: #667eea;">
                    ‚úÖ ƒê√£ ho√†n th√†nh b√†i thi
                </div>
            `;
                modalMessage.textContent = message || 'B√†i thi c·ªßa b·∫°n ƒëang ch·ªù gi√°o vi√™n ch·∫•m ƒëi·ªÉm. ƒêi·ªÉm s·ªë s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau khi gi√°o vi√™n ho√†n t·∫•t ch·∫•m b√†i.';
            } else {
                // Format ƒëi·ªÉm: lo·∫°i b·ªè .0 khi kh√¥ng c·∫ßn
                const scoreNum = parseFloat(score || 0);
                const totalNum = parseFloat(totalPoints || 0);
                const displayScore = scoreNum % 1 === 0 ? scoreNum.toString() : scoreNum.toFixed(1);
                const displayTotal = totalNum % 1 === 0 ? totalNum.toString() : totalNum.toFixed(1);

                modalScore.textContent = `${displayScore}/${displayTotal}`;
                modalMessage.textContent = message || 'N·ªôp b√†i th√†nh c√¥ng!';
            }

            modal.style.display = 'flex';

            modal.dataset.examId = examData.exam_id;
            modal.dataset.attemptId = examData.attempt_id;
        }

        function closeModal() {
            document.getElementById('submitModal').style.display = 'none';
            goToResult();
        }

        function goToResult() {
            const modal = document.getElementById('submitModal');
            const examId = modal.dataset.examId;
            const attemptId = modal.dataset.attemptId;
            window.location.href = `./student_result.html?exam_id=${examId}&attempt_id=${attemptId}`;
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => toast.classList.add('show'), 100);

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }

        function showWarning(message) {
            const warningId = `warning_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            console.log(`üîç [DEBUG] [${warningId}] showWarning START:`, message);
            console.log(`üîç [DEBUG] [${warningId}] showWarning stack:`, new Error().stack);

            try {
                const banner = document.getElementById('warningBanner');
                if (!banner) {
                    console.error(`‚ùå [DEBUG] [${warningId}] Kh√¥ng t√¨m th·∫•y warningBanner element!`);
                    return;
                }
                console.log(`üîç [DEBUG] [${warningId}] Banner element found, setting message...`);
                banner.textContent = message;
                banner.classList.add('show');
                console.log(`üîç [DEBUG] [${warningId}] Banner ƒë√£ hi·ªÉn th·ªã`);

                setTimeout(() => {
                    console.log(`üîç [DEBUG] [${warningId}] Hiding banner after 3s...`);
                    banner.classList.remove('show');
                    console.log(`üîç [DEBUG] [${warningId}] Banner ƒë√£ ·∫©n`);
                }, 3000);
                console.log(`üîç [DEBUG] [${warningId}] showWarning END`);
            } catch (error) {
                console.error(`‚ùå [DEBUG] [${warningId}] L·ªói showWarning:`, error);
                console.error(`‚ùå [DEBUG] [${warningId}] Error stack:`, error.stack);
            }
        }

        // L∆∞u d·ªØ li·ªáu ƒë·ªãnh k·ª≥ ƒë·ªÉ tr√°nh m·∫•t d·ªØ li·ªáu khi reload
        setInterval(() => {
            if (examData && examData.attempt_id && examData.exam_id) {
                try {
                    localStorage.setItem('exam_answers', JSON.stringify(answers));
                    localStorage.setItem('current_exam', JSON.stringify(examData));
                } catch (err) {
                    console.error('‚ùå L·ªói l∆∞u d·ªØ li·ªáu:', err);
                }
            }
        }, 5000); // L∆∞u m·ªói 5 gi√¢y

        // ‚≠ê X√ìA beforeunload listener n√†y - ƒë√£ c√≥ listener ·ªü tr√™n ƒë·ªÉ block reload
        // D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c l∆∞u ƒë·ªãnh k·ª≥ m·ªói 5 gi√¢y, kh√¥ng c·∫ßn listener n√†y
        // KH√îNG th√™m listener m·ªõi ƒë·ªÉ tr√°nh conflict v√† popup

        // ‚≠ê X√ìA pagehide listener - KH√îNG C·∫¶N THI·∫æT
        // pagehide event c√≥ th·ªÉ trigger khi page reload, g√¢y ra v√≤ng l·∫∑p
        // Thay v√†o ƒë√≥, ch·ªâ cleanup khi user th·ª±c s·ª± submit exam ho·∫∑c ƒë√≥ng tab
        // KH√îNG cleanup khi page reload t·ª± ƒë·ªông

        document.addEventListener('input', (e) => {
            if (e.target.id === 'textAnswer') {
                const question = examData.questions[currentQuestionIndex];
                answers[question.question_id] = e.target.value;
                updateAnsweredStatus();
                autoSaveAnswer(question.question_id, e.target.value, null);
            }
        });
    </script>
</body>

</html>